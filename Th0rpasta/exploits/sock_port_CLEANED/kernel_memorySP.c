//
//  kernel_memory.c
//  sock_port
//
//  Created by Jake James on 7/18/19.
//  Copyright Â© 2019 Jake James. All rights reserved.
//

#include "kernel_memorySP.h"
#include "parameters.h"
uint64_t current_task_s3_s3;
u_int64_t itk_space_s3;
u_int64_t itk_space_size_s3;
u_int64_t itk_space_istable_s3;
u_int64_t itk_space_vm_s3;
u_int64_t itk_space_port_s3;
uint64_t current_proc_OOB;
uint64_t current_task_OOB;
static mach_port_t tfpzero;
//uint64_t basefromkernelmemory;
//uint64_t slidefromkernelmemory;
uint32_t newClientSP_s31;

uint64_t ourprocFinal_s3;
uint64_t kernprocFinal_s3;
uint64_t iosruc_port_OOB1;
uint64_t iosruc_addr_OOB1;
uint64_t iosruc_vtab_OOB1;


void init_kernel_memorySP(mach_port_t tfp0) {
    tfpzero = tfp0;
}
uint64_t kallocSP(vm_size_t size) {
    mach_vm_address_t address = 0;
    mach_vm_allocate(tfpzero, (mach_vm_address_t *)&address, size, VM_FLAGS_ANYWHERE);
    return address;
}

void kfreeSP(mach_vm_address_t address, vm_size_t size) {
    mach_vm_deallocate(tfpzero, address, size);
}

size_t kreadSP(uint64_t where, void *p, size_t size) {
    int rv;
    size_t offset = 0;
    while (offset < size) {
        mach_vm_size_t sz, chunk = 2048;
        if (chunk > size - offset) {
            chunk = size - offset;
        }
        rv = mach_vm_read_overwrite(tfpzero, where + offset, chunk, (mach_vm_address_t)p + offset, &sz);
        if (rv || sz == 0) {
            printf("[-] error on kread(0x%016llx)\n", where);
            break;
        }
        offset += sz;
    }
    return offset;
}

uint32_t rk32SP(uint64_t where) {
    uint32_t out;
    kreadSP(where, &out, sizeof(uint32_t));
    return out;
}

uint64_t rk64SP(uint64_t where) {
    uint64_t out;
    kreadSP(where, &out, sizeof(uint64_t));
    return out;
}

size_t kwriteSP(uint64_t where, const void *p, size_t size) {
    int rv;
    size_t offset = 0;
    while (offset < size) {
        size_t chunk = 2048;
        if (chunk > size - offset) {
            chunk = size - offset;
        }
        rv = mach_vm_write(tfpzero, where + offset, (mach_vm_offset_t)p + offset, (int)chunk);
        if (rv) {
            printf("[-] error on kwrite(0x%016llx)\n", where);
            break;
        }
        offset += chunk;
    }
    return offset;
}

void wk32SP(uint64_t where, uint32_t what) {
    uint32_t _what = what;
    kwriteSP(where, &_what, sizeof(uint32_t));
}


void wk64SP(uint64_t where, uint64_t what) {
    uint64_t _what = what;
    kwriteSP(where, &_what, sizeof(uint64_t));
}

uint64_t find_port_SP(mach_port_name_t port, uint64_t task_self) {
    uint64_t task_addr = rk64SP(task_self + koffsetS3(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
    uint64_t itk_space = rk64SP(task_addr + OFFSET(task, itk_space));
    uint64_t is_table = rk64SP(itk_space + OFFSET(ipc_space, is_table));
    
    uint32_t port_index = port >> 8;
    const int sizeof_ipc_entry_t = 0x18;
    
    uint64_t port_addr = rk64SP(is_table + (port_index * sizeof_ipc_entry_t));
    
    return port_addr;
}
